package registry

import (
	"path"
	"time"

	"github.com/coreos/go-etcd/etcd"
	log "github.com/golang/glog"

	"github.com/coreos/coreinit/job"
)

const (
	statePrefix = "/state/"
)

// Get the current JobState of the provided Job
func (r *Registry) GetJobState(j *job.Job) *job.JobState {
	key := path.Join(keyPrefix, statePrefix, j.Name)
	resp, err := r.etcd.Get(key, false, true)

	// Assume the error was KeyNotFound and return an empty data structure
	if err != nil {
		return nil
	}

	var state job.JobState
	//TODO: Handle the error generated by unmarshal
	unmarshal(resp.Node.Value, &state)
	return &state
}

// Persist the changes in a provided Machine's Job to etcd with the provided TTL
func (r *Registry) SaveJobState(j *job.Job, ttl time.Duration) {
	key := path.Join(keyPrefix, statePrefix, j.Name)
	//TODO: Handle the error generated by marshal
	json, _ := marshal(j.State)
	r.etcd.Set(key, json, uint64(ttl.Seconds()))
}

func filterEventJobStatePublished(resp *etcd.Response) *Event {
	if resp.Action != "set" {
		return nil
	}

	var js job.JobState
	err := unmarshal(resp.Node.Value, &js)
	if err != nil {
		log.V(1).Infof("Failed to deserialize JobState: %s", err)
		return nil
	}

	//TODO: handle error returned by NewJob
	j, _ := job.NewJob(path.Base(resp.Node.Key), &js, nil)
	return &Event{"EventJobStatePublished", *j, nil}
}

func filterEventJobStateExpired(resp *etcd.Response) *Event {
	if resp.Action != "delete" && resp.Action != "expire" {
		return nil
	}

	var js job.JobState
	err := unmarshal(resp.Node.Value, &js)
	if err != nil {
		log.V(1).Infof("Failed to deserialize JobState: %s", err)
		return nil
	}

	//TODO: handle error returned by NewJob
	j, _ := job.NewJob(path.Base(resp.Node.Key), &js, nil)
	return &Event{"EventJobStateExpired", *j, nil}
}
