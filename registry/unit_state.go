package registry

import (
	"path"

	log "github.com/coreos/fleet/Godeps/_workspace/src/github.com/golang/glog"

	"github.com/coreos/fleet/etcd"
	"github.com/coreos/fleet/machine"
	"github.com/coreos/fleet/unit"
)

const (
	statePrefix = "/state/"
)

// Get the current UnitState of the provided Job's Unit
func (r *EtcdRegistry) getUnitState(jobName string) *unit.UnitState {
	req := etcd.Get{
		Key:       path.Join(r.keyPrefix, statePrefix, jobName),
		Recursive: true,
	}
	resp, err := r.etcd.Do(&req)

	// Assume the error was KeyNotFound and return an empty data structure
	if err != nil {
		return nil
	}

	var usm unitStateModel
	//TODO: Handle the error generated by unmarshal
	unmarshal(resp.Node.Value, &usm)

	return modelToUnitState(&usm)
}

// Persist the changes in a provided Machine's Job
func (r *EtcdRegistry) SaveUnitState(jobName string, unitState *unit.UnitState) {
	usm := unitStateToModel(unitState)
	if usm == nil {
		log.Errorf("Unable to save nil UnitState model")
		return
	}

	//TODO: Handle the error generated by marshal
	json, _ := marshal(usm)

	req := etcd.Set{
		Key:   path.Join(r.keyPrefix, statePrefix, jobName),
		Value: json,
	}
	r.etcd.Do(&req)
}

// Delete the state from the Registry for the given Job's Unit
func (r *EtcdRegistry) RemoveUnitState(jobName string) error {
	req := etcd.Delete{
		Key: path.Join(r.keyPrefix, statePrefix, jobName),
	}
	_, err := r.etcd.Do(&req)
	if isKeyNotFound(err) {
		err = nil
	}
	return err
}

type unitStateModel struct {
	LoadState    string                `json:"loadState"`
	ActiveState  string                `json:"activeState"`
	SubState     string                `json:"subState"`
	MachineState *machine.MachineState `json:"machineState"`
}

func modelToUnitState(usm *unitStateModel) *unit.UnitState {
	if usm == nil {
		return nil
	}

	us := unit.UnitState{
		LoadState:   usm.LoadState,
		ActiveState: usm.ActiveState,
		SubState:    usm.SubState,
	}

	if usm.MachineState != nil {
		us.MachineID = usm.MachineState.ID
	}

	return &us
}

func unitStateToModel(us *unit.UnitState) *unitStateModel {
	if us == nil {
		return nil
	}

	usm := unitStateModel{
		LoadState:   us.LoadState,
		ActiveState: us.ActiveState,
		SubState:    us.SubState,
	}

	if us.MachineID != "" {
		usm.MachineState = &machine.MachineState{ID: us.MachineID}
	}

	return &usm
}
