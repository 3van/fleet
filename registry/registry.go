package registry

import (
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"path"
	"time"

	"github.com/coreos/go-etcd/etcd"

	"github.com/coreos/coreinit/job"
	"github.com/coreos/coreinit/machine"
)

const (
	keyPrefix      = "/coreos.com/coreinit/"
	lockPrefix     = "/locks/"
	machinePrefix  = "/machines/"
	requestPrefix = "/request/"
	schedulePrefix = "/schedule/"
	scheduleAllPrefix = "/schedule-all/"
	statePrefix    = "/state/"
)

type Registry struct {
	Etcd   *etcd.Client
}

func New() (registry *Registry) {
	etcdC := etcd.NewClient(nil)
	return &Registry{etcdC}
}

// Describe the list of all known Machines
func (r *Registry) GetActiveMachines() map[string]machine.Machine {
	key := path.Join(keyPrefix, machinePrefix)
	resp, err := r.Etcd.Get(key, false)

	// Assume the error was KeyNotFound and return an empty data structure
	if err != nil {
		return make(map[string]machine.Machine, 0)
	}

	machines := make(map[string]machine.Machine, len(resp.Kvs))
	for _, kv := range resp.Kvs {
		_, bootId := path.Split(kv.Key)
		machine := machine.New(bootId)

		// This is a hacky way of telling if a Machine is reporting state
		addrs := r.GetMachineAddrs(machine)
		if len(addrs) > 0 {
			machines[machine.BootId] = *machine
		}
	}

	return machines
}

func (r *Registry) GetMachineAddrs(m *machine.Machine) []machine.IPAddress {
	key := path.Join(keyPrefix, machinePrefix, m.BootId, "addrs")
	resp, err := r.Etcd.Get(key, false)

	addrs := make([]machine.IPAddress, 0)

	// Assume this is KeyNotFound and return an empty data structure
	if err != nil {
		return addrs
	}

	//TODO: Handle the error generated by unmarshal
	unmarshal(resp.Value, &addrs)

	return addrs
}

func (r *Registry) SetMachineAddrs(machine *machine.Machine, addrs []machine.IPAddress, ttl time.Duration) {
	//TODO: Handle the error generated by marshal
	json, _ := marshal(addrs)
	key := path.Join(keyPrefix, machinePrefix, machine.BootId, "addrs")
	r.Etcd.Set(key, json, uint64(ttl.Seconds()))
}

func (r *Registry) AddRequest(req *job.JobRequest) {
	key := path.Join(keyPrefix, requestPrefix, req.ID.String())
	//TODO: Handle the error generated by marshal
	json, _ := marshal(req)
	r.Etcd.Set(key, json, 0)
}

func (r *Registry) ClaimRequest(m *machine.Machine, ttl time.Duration) *job.JobRequest {
	key := path.Join(keyPrefix, requestPrefix)
	resp, err := r.Etcd.Get(key, false)

	// Assume the error was KeyNotFound and return an empty data structure
	if err != nil {
		return nil
	}

	var request job.JobRequest

	// Attempt to lock each JobRequest, returning when a lock is acquired
	for _, kv := range resp.Kvs {
		if !r.AcquireLock(kv.Key, m.BootId, ttl) {
			continue
		}

		if err := unmarshal(kv.Value, &request); err == nil {
			return &request
		} else {
			log.Print(err)
		}
	}

	// No jobs to claim
	return nil
}

func (r *Registry) ResolveRequest(req *job.JobRequest) {
	key := path.Join(keyPrefix, requestPrefix, req.ID.String())
	r.Etcd.Delete(key)
	log.Printf("Resolved job request %s", req.ID.String())
}

func (r *Registry) GetGlobalJobs() map[string]job.Job {
	machines := r.GetActiveMachines()
	jobs := map[string]job.Job{}
	for _, mach := range machines {
		for name, value := range r.GetMachineJobs(&mach) {
			//FIXME: This will hide duplicate jobs!
			jobs[name] = value
		}
	}
	return jobs
}

// Describe the list of jobs a given Machine is scheduled to run
func (r *Registry) GetMachineJobs(machine *machine.Machine) map[string]job.Job {
	key := path.Join(keyPrefix, machinePrefix, machine.BootId, schedulePrefix)
	resp, err := r.Etcd.Get(key, false)

	// Assume the error was KeyNotFound and return an empty data structure
	if err != nil {
		return make(map[string]job.Job, 0)
	}

	jobs := make(map[string]job.Job, len(resp.Kvs))
	for _, kv := range resp.Kvs {
		name := path.Base(kv.Key)

		var payload job.JobPayload
		err := unmarshal(kv.Value, &payload)

		if err == nil {
			job, _ := job.NewJob(name, nil, &payload)
			jobs[job.Name] = *job
		} else {
			log.Print(err)
		}
	}
	return jobs
}

func (r *Registry) GetJobPayload(j *job.Job) *job.JobPayload {
	key := path.Join(keyPrefix, schedulePrefix, j.Name)
	resp, err := r.Etcd.Get(key, false)

	// Assume the error was KeyNotFound and return an empty data structure
	if err != nil {
		return nil
	}

	var payload job.JobPayload
	//TODO: Handle the error generated by unmarshal
	unmarshal(resp.Value, &payload)
	return &payload
}

func (r *Registry) GetJobState(j *job.Job) *job.JobState {
	key := path.Join(keyPrefix, statePrefix, j.Name)
	resp, err := r.Etcd.Get(key, false)

	// Assume the error was KeyNotFound and return an empty data structure
	if err != nil {
		return nil
	}

	var state job.JobState
	//TODO: Handle the error generated by unmarshal
	unmarshal(resp.Value, &state)
	return &state
}

func (r *Registry) ScheduleClusterJob(job *job.Job) {
	key := path.Join(keyPrefix, scheduleAllPrefix, job.Name)
	//TODO: Handle the error generated by marshal
	json, _ := marshal(job.Payload)
	r.Etcd.Set(key, json, 0)
}

func (r *Registry) RegisterJobListener(eventchan chan JobEvent) {
	etcdchan := make(chan *etcd.Response)

	eventTranslater := func() {
		for true {
			resp := <-etcdchan

			name := path.Base(resp.Key)

			var eventType int
			if len(resp.PrevValue) == 0 {
				eventType = EventJobCreated
			} else {
				eventType = EventJobDeleted
			}

			var jp job.JobPayload
			err := unmarshal(resp.Value, &jp)
			if err != nil {
				log.Printf("Failed to deserialize payload for job '%s'", name)
				continue
			}

			j, _ := job.NewJob(name, nil, &jp)
			event := JobEvent{eventType, j}

			eventchan<- event
		}
	}

	go eventTranslater()

	key := path.Join(keyPrefix, scheduleAllPrefix)
	go r.Etcd.WatchAll(key, 0, etcdchan, nil)
}

func (r *Registry) RegisterMachineListener(eventchan chan MachineEvent) {
	etcdchan := make(chan *etcd.Response)

	eventTranslater := func() {
		for true {
			resp := <-etcdchan

			dir, base := path.Split(resp.Key)
			if base != "addrs" {
				continue
			}

			var eventType int
			if resp.PrevValue == "" {
				eventType = EventMachineCreated
			} else {
				eventType = EventMachineDeleted
			}

			name := path.Base(dir)
			m := machine.New(name)
			event := MachineEvent{eventType, m}

			eventchan<- event
		}
	}

	go eventTranslater()

	key := path.Join(keyPrefix, machinePrefix)
	go r.Etcd.WatchAll(key, 0, etcdchan, nil)
}

func (r *Registry) ScheduleMachineJob(job *job.Job, machine *machine.Machine) {
	key := path.Join(keyPrefix, machinePrefix, machine.BootId, schedulePrefix, job.Name)
	//TODO: Handle the error generated by marshal
	json, _ := marshal(job.Payload)
	r.Etcd.Set(key, json, 0)
}

// StopJob removes the job from the global and machine schedule.
func (r *Registry) StopJob(job *job.Job) {
	key := path.Join(keyPrefix, schedulePrefix, job.Name)
	r.Etcd.Delete(key)

	state := r.GetJobState(job)

	if state != nil {
		key := path.Join(keyPrefix, machinePrefix, state.Machine.BootId, schedulePrefix, job.Name)
		r.Etcd.Delete(key)
	}
}

// Persist the changes in a provided Machine's Job to Etcd with the provided TTL
func (r *Registry) UpdateJob(job *job.Job, ttl uint64) {
	key := path.Join(keyPrefix, statePrefix, job.Name)
	//TODO: Handle the error generated by marshal
	json, _ := marshal(job.State)
	r.Etcd.Set(key, json, ttl)
}

// Attempt to acquire a lock in Etcd on an arbitrary string. Returns true if
// successful, otherwise false.
func (r *Registry) AcquireLock(name string, context string, ttl time.Duration) bool {
	key := path.Join(keyPrefix, lockPrefix, name)
	_, err := r.Etcd.Create(key, context, uint64(ttl.Seconds()))
	return err == nil
}

func marshal(obj interface{}) (string, error) {
	encoded, err := json.Marshal(obj)
	if err == nil {
		return string(encoded), nil
	} else {
		return "", errors.New(fmt.Sprintf("Unable to JSON-serialize object: %s", err))
	}
}

func unmarshal(val string, obj interface{}) error {
	err := json.Unmarshal([]byte(val), &obj)
	if err == nil {
		return nil
	} else {
		return errors.New(fmt.Sprintf("Unable to JSON-deserialize object: %s", err))
	}
}
